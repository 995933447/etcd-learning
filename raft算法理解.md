<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [ETCD的Raft一致性算法原理](#etcd%E7%9A%84raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86)
  - [Raft原理了解](#raft%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3)
    - [raft中的几种状态](#raft%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81)
    - [任期](#%E4%BB%BB%E6%9C%9F)
    - [leader选举](#leader%E9%80%89%E4%B8%BE)
    - [日志复制](#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## ETCD的Raft一致性算法原理

### Raft原理了解

Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。 

Raft是一种分布式一致性算法。它被设计得易于理解, 解决了即使在出现故障时也可以让多个服务器对共享状态达成一致的问题。共享状态通常是通过日志复制支持的数据结构。只要大多数服务器是正常运作的，系统就能全面运行。  

Raft的工作方式是在集群中选举一个领导者。领导者负责接受客户端请求并管理到其他服务器的日志复制。数据只在一个方向流动:从领导者到其他服务器。  

Raft将一致性问题分解为三个子问题:

- 领导者选举: 现有领导者失效时，需要选举新的领导者；  

- 日志复制: 领导者需要通过复制保持所有服务器的日志与自己的同步；  

- 安全性: 如果其中一个服务器在特定索引上提交了日志条目，那么其他服务器不能在该索引应用不同的日志条目。   

#### raft中的几种状态  

在raft算法中，在任何时刻，每一个服务器节点都处于这三个状态之一：  

- Follower:追随者，跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导者或者候选人的请求；  

- Candidate:候选人，如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举，获得集群中大多数选票的候选人将成为领导者。  

- Leader:领导者，系统中只有一个领导人并且其他的节点全部都是跟随者，领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）   

来看下几个状态的关系  

<img src="/img/raft_1.png" alt="etcd" align=center/>

#### 任期  

Raft将时间划分为任意长度的任期，每个任期都以一次选举开始。如果一名候选人赢得选举，他在剩下的任期时间内仍然是领导者。如果投票出现分歧，那么这个任期则没有领导者,及时结束。  

任期号单调递增。每个服务器存储当前任期号，并在每次通信中交换该任期编号。  

如果一个服务器的当前任期号小于其他服务器，那么它将把当前任期更新为更大的值。如果候选人或领导者发现其任期已过期，则立即转化为追随者状态。如果服务器接收到带有过期任期号的请求，它将拒绝该请求。  

#### leader选举  

领导者定期向跟随者发送心跳，来维持自己的leader角色。如果跟随者在一定的时间内没有接收到任何的消息，也就是选举超时，那么他就会认为系统中没有可用的领导者,并且发起选举以选出新的领导者。  

要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。  

候选人的选举会有下面三种结果：   

1、候选人自己赢得了选举；  

2、其他服务成为了leader；  

3、候选人中没有选出领导者，可能是多个跟随者同时成为候选人，然后选票被瓜分了，以至于没有候选人能获得最大的票数。这种情况下面详细介绍。  

对于选举过程，对于选票被瓜分的情况，Raft算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。  

来看下这个选举的随机算法：  

1、为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择；  

2、这个选举超时时间就是follower要等待成为candidate的时间；  

3、每一个候选人在开始一次选举的时候会重置一个随机超时的时间，也就是150-300中随机一个值；   

4、这个时间结束之后follower变成candidate开始选举；  

5、这样大大减少了选票被瓜分的情况，如何选票还是被瓜分，就继续从1开始选举。    

#### 日志复制

一旦leader被选举成功，就可以对客户端提供服务了。客户端提交每一条命令都会被按顺序记录到leader的日志中，每一条命令都包含term编号和顺序索引，然后向其他节点并行发送AppendEntries RPC用以复制命令(如果命令丢失会不断重发)，当复制成功也就是大多数节点成功复制后，leader就会提交命令，即执行该命令并且将执行结果返回客户端，raft保证已经提交的命令最终也会被其他节点成功执行。  




  





### 参考  

【一文搞懂Raft算法】https://www.cnblogs.com/xybaby/p/10124083.html    
【寻找一种易于理解的一致性算法（扩展版）】https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md  
【raft演示动画】https://raft.github.io/raftscope/index.html    
【理解 raft 算法】https://sanyuesha.com/2019/04/18/raft/  
【理解Raft一致性算法—一篇学术论文总结】https://mp.weixin.qq.com/s/RkMeYyUck1WQPjNiGvahKQ  
【Raft协议原理详解】https://zhuanlan.zhihu.com/p/91288179  
【Raft算法详解】https://zhuanlan.zhihu.com/p/32052223  

